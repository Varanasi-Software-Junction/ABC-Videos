<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Content Expand-to-Fullscreen — Auto-switch on Visibility</title>
  <style>
    :root{
      --bg:#fafafa;
      --box-bg:#e8e8e8;
      --highlight:#2a9d8f;
      --anim-duration:520ms;
      --close-size:44px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      background:var(--bg);
      color:#111;
    }

    .spacer { height:100vh; display:flex; align-items:center; justify-content:center; color:#666; }

    .content {
      min-height: 60vh;
      margin: 48px 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: var(--box-bg);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.06);
      padding: 28px;
      text-align:center;
      font-size: 1.1rem;
      transition: none;
      will-change: transform, left, top, width, height;
      position: relative;
      overflow: hidden;
    }

    .content .inner { max-width: 900px; width:100%; }

    .content.visible { box-shadow: 0 12px 36px rgba(0,0,0,0.10); }

    .expanding { border-radius: 10px; }

    .exp-close {
      position: fixed;
      right: 18px;
      top: 18px;
      width: var(--close-size);
      height: var(--close-size);
      border-radius: 8px;
      border: 0;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      cursor:pointer;
      z-index: 12001;
    }

    @media (prefers-reduced-motion: reduce) {
      :root { --anim-duration: 0ms; }
      .content { transition: none !important; }
    }

    footer.note { text-align:center; color:#666; padding:18px; font-size:.95rem;}
  </style>
</head>
<body>
  <div class="spacer">Scroll down — sections expand to fullscreen when visible. If another becomes visible, it will replace the current.</div>

  <section class="content" id="c1"><div class="inner"><h2>Section A</h2><p>Content A — expands to fullscreen.</p></div></section>
  <section class="content" id="c2"><div class="inner"><h2>Section B</h2><p>Content B — will replace A when visible.</p></div></section>
  <section class="content" id="c3"><div class="inner"><h2>Section C</h2><p>Content C — will replace whoever is open.</p></div></section>
  <section class="content" id="c4"><div class="inner"><h2>Section D</h2><p>Content D — last section.</p></div></section>

  <div class="spacer"></div>

  <footer class="note">Auto-switch demo: expands the actual .content element (fixed positioning + transform).</footer>

  <script>
    (function(){
      const sections = Array.from(document.querySelectorAll('.content'));
      const animDuration = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--anim-duration')) || 520;
      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      let currentlyExpanded = null;
      let placeholder = null;
      let closeBtn = null;
      let isAnimating = false; // prevents overlapping expand/shrink

      // Helper to fix element at rect
      function fixElementAtRect(el, rect) {
        el.style.position = 'fixed';
        el.style.left = rect.left + 'px';
        el.style.top = rect.top + 'px';
        el.style.width = rect.width + 'px';
        el.style.height = rect.height + 'px';
        el.style.margin = '0';
        el.style.zIndex = 12000;
        el.classList.add('expanding');
      }

      function restoreElement(el) {
        el.style.position = '';
        el.style.left = '';
        el.style.top = '';
        el.style.width = '';
        el.style.height = '';
        el.style.margin = '';
        el.style.zIndex = '';
        el.style.transform = '';
        el.style.transition = '';
        el.classList.remove('expanding');
      }

      // Create close button once
      function ensureCloseButton() {
        if (closeBtn) return;
        closeBtn = document.createElement('button');
        closeBtn.className = 'exp-close';
        closeBtn.innerHTML = '✕';
        closeBtn.title = 'Close';
        document.body.appendChild(closeBtn);
        closeBtn.addEventListener('click', () => {
          if (!isAnimating) shrinkCurrent();
        });
      }

      function removeCloseButton() {
        if (!closeBtn) return;
        closeBtn.removeEventListener('click', shrinkCurrent);
        if (closeBtn.parentNode) closeBtn.parentNode.removeChild(closeBtn);
        closeBtn = null;
      }

      // Expand a section (returns a Promise that resolves when expansion finishes)
      function expandContent(section) {
        return new Promise((resolve) => {
          if (isAnimating) { resolve(); return; }
          isAnimating = true;
          ensureCloseButton();

          const rect = section.getBoundingClientRect();
          const vw = window.innerWidth;
          const vh = window.innerHeight;

          // placeholder to preserve flow
          placeholder = document.createElement('div');
          placeholder.style.width = rect.width + 'px';
          placeholder.style.height = rect.height + 'px';
          placeholder.style.margin = getComputedStyle(section).margin;
          section.parentNode.insertBefore(placeholder, section);

          fixElementAtRect(section, rect);

          const scaleX = vw / rect.width;
          const scaleY = vh / rect.height;
          const translateX = -rect.left;
          const translateY = -rect.top;

          section.style.transition = `transform ${animDuration}ms cubic-bezier(.22,.9,.35,1)`;
          section.getBoundingClientRect(); // force layout

          if (prefersReduced) {
            section.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
            // immediate resolve
            isAnimating = false;
            currentlyExpanded = section;
            resolve();
            return;
          }

          function onEnd() {
            section.removeEventListener('transitionend', onEnd);
            isAnimating = false;
            currentlyExpanded = section;
            resolve();
          }

          // fallback in case transitionend doesn't fire
          let called = false;
          const fallback = setTimeout(() => {
            if (!called) { called = true; onEnd(); }
          }, animDuration + 80);

          section.addEventListener('transitionend', () => {
            if (called) return;
            called = true;
            clearTimeout(fallback);
            onEnd();
          }, { once: true });

          // animate
          requestAnimationFrame(() => {
            section.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
            // focus close button for accessibility
            if (closeBtn) closeBtn.focus();
          });
        });
      }

      // Shrink current (returns Promise)
      function shrinkCurrent() {
        return new Promise((resolve) => {
          if (!currentlyExpanded) { resolve(); return; }
          if (isAnimating) { resolve(); return; } // avoid double-shrink
          isAnimating = true;
          const section = currentlyExpanded;
          const rect = placeholder.getBoundingClientRect();
          const vw = window.innerWidth;
          const vh = window.innerHeight;

          const scaleX = rect.width / vw;
          const scaleY = rect.height / vh;
          const translateX = rect.left;
          const translateY = rect.top;

          section.style.transition = `transform ${animDuration}ms cubic-bezier(.22,.9,.35,1)`;

          if (prefersReduced) {
            // instant restore
            restoreElement(section);
            if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
            placeholder = null;
            removeCloseButton();
            currentlyExpanded = null;
            isAnimating = false;
            resolve();
            return;
          }

          function onEnd() {
            section.removeEventListener('transitionend', onEnd);
            restoreElement(section);
            if (placeholder && placeholder.parentNode) placeholder.parentNode.removeChild(placeholder);
            placeholder = null;
            removeCloseButton();
            currentlyExpanded = null;
            isAnimating = false;
            resolve();
          }

          // fallback in case transitionend doesn't fire
          let called = false;
          const fallback = setTimeout(() => {
            if (!called) { called = true; onEnd(); }
          }, animDuration + 80);

          section.addEventListener('transitionend', () => {
            if (called) return;
            called = true;
            clearTimeout(fallback);
            onEnd();
          }, { once: true });

          // animate back
          requestAnimationFrame(() => {
            section.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
          });
        });
      }

      // IntersectionObserver: when a section becomes visible, expand it.
      // If another section is expanded, shrink it first, then expand the new one.
      const obsOptions = { root: null, rootMargin: '0px 0px -10% 0px', threshold: 0.5 };
      const observer = new IntersectionObserver(async (entries) => {
        // find best candidate (highest ratio) that is intersecting
        let best = null;
        entries.forEach(e => {
          if (!best || e.intersectionRatio > best.intersectionRatio) best = e;
          // toggle subtle visible class
          if (e.isIntersecting && e.intersectionRatio >= obsOptions.threshold) e.target.classList.add('visible');
          else e.target.classList.remove('visible');
        });

        if (!best) return;
        if (best.isIntersecting && best.intersectionRatio >= obsOptions.threshold) {
          const target = best.target;
          // if already expanded to same target, nothing to do
          if (currentlyExpanded === target) return;

          // if another is expanded, shrink it first
          if (currentlyExpanded && currentlyExpanded !== target) {
            await shrinkCurrent();
            // small micro-delay to ensure layout stabilized before expanding next (helps on some browsers)
            await new Promise(res => requestAnimationFrame(res));
          }

          // expand the target (only if no one else expanded it in the meantime)
          if (!currentlyExpanded) {
            await expandContent(target);
          }
        }
      }, obsOptions);

      sections.forEach(s => observer.observe(s));

      // Close on ESC
      window.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && currentlyExpanded && !isAnimating) {
          shrinkCurrent();
        }
      });

      // Clicking outside expanded section closes it
      document.addEventListener('click', (ev) => {
        if (!currentlyExpanded || isAnimating) return;
        if (currentlyExpanded.contains(ev.target)) return;
        if (closeBtn && closeBtn.contains(ev.target)) return;
        // shrink
        shrinkCurrent();
      }, true);

      // Handle resize while expanded: keep it covering viewport
      window.addEventListener('resize', () => {
        if (!currentlyExpanded) return;
        // recompute transform to remain covering viewport
        const section = currentlyExpanded;
        const rect = placeholder ? placeholder.getBoundingClientRect() : section.getBoundingClientRect();
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const scaleX = vw / rect.width;
        const scaleY = vh / rect.height;
        const translateX = -rect.left;
        const translateY = -rect.top;
        // apply immediately without transition to avoid flicker
        section.style.transition = 'transform 0ms';
        section.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scaleX}, ${scaleY})`;
      });

    })();
  </script>
</body>
</html>
